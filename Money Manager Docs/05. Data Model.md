# üìä Data Model & Swift Data Schema

## üéØ Purpose

Define the core data structures and relationships for the Money Manager app using Swift Data.

---

## üß© Part 1: Core Entities

### Entity 1: Expense

**Purpose**: Single transaction (one-time or auto-generated)

```swift
@Model
final class Expense {
    // Identifiers
    @Attribute(.unique) var id: UUID
    
    // Core Fields
    var amount: Double              // ‚Çπ450.00
    var category: String            // "Food & Dining" or UUID (custom)
    var date: Date                  // Date component only
    var time: Date?                 // Optional time (HH:MM)
    var description: String?        // "Lunch at cafe"
    var notes: String?              // Additional notes
    
    // Metadata
    var createdAt: Date             // When record was created
    var updatedAt: Date             // Last modified
    var isDeleted: Bool = false     // Soft delete
    
    // Relationships
    var recurringExpenseId: UUID?   // Link to recurring template (if auto-generated)
    
    // Recurring Indicator
    var isRecurring: Bool = false   // Is this a recurring template or generated from one?
    
    init(
        amount: Double,
        category: String,
        date: Date,
        time: Date? = nil,
        description: String? = nil,
        notes: String? = nil,
        recurringExpenseId: UUID? = nil
    ) {
        self.id = UUID()
        self.amount = amount
        self.category = category
        self.date = date
        self.time = time
        self.description = description
        self.notes = notes
        self.recurringExpenseId = recurringExpenseId
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}
```

---

### Entity 2: RecurringExpense

**Purpose**: Template for auto-generated expenses

```swift
@Model
final class RecurringExpense {
    // Identifiers
    @Attribute(.unique) var id: UUID
    
    // Core Fields
    var name: String                // "Rent", "Netflix", "Gym"
    var amount: Double              // ‚Çπ15,000
    var category: String            // "Housing"
    var frequency: String           // "Daily", "Weekly", "Monthly"
    var notes: String?              // Additional notes
    
    // Recurrence Pattern
    var startDate: Date             // First occurrence date
    var endDate: Date?              // Last occurrence date (nil = ongoing)
    var dayOfWeek: [Int]?           // For weekly (0=Sun, 1=Mon, etc.)
    var dayOfMonth: Int?            // For monthly (1-31)
    var skipWeekends: Bool = false  // For daily
    var skipDates: [Date]?          // Specific dates to skip
    
    // Metadata
    var isActive: Bool = true       // Pause/Resume flag
    var createdAt: Date
    var updatedAt: Date
    
    // Relationships
    var generatedExpenses: [Expense]?  // Auto-generated expenses
    
    // Last Generation Tracking
    var lastGeneratedDate: Date?    // Last date an expense was generated
    
    init(
        name: String,
        amount: Double,
        category: String,
        frequency: String,
        startDate: Date,
        endDate: Date? = nil,
        dayOfMonth: Int? = nil,
        dayOfWeek: [Int]? = nil
    ) {
        self.id = UUID()
        self.name = name
        self.amount = amount
        self.category = category
        self.frequency = frequency
        self.startDate = startDate
        self.endDate = endDate
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}
```

---

### Entity 3: CustomCategory

**Purpose**: User-created categories

```swift
@Model
final class CustomCategory {
    // Identifiers
    @Attribute(.unique) var id: UUID
    
    // Fields
    var name: String                // "Subscriptions"
    var icon: String                // "üé¨" (emoji)
    var color: String               // Hex: "#FF6B6B"
    var isHidden: Bool = false      // Soft delete
    
    // Metadata
    var createdAt: Date
    var updatedAt: Date
    
    // Relationships
    var expenses: [Expense]?        // Expenses using this category
    
    init(name: String, icon: String, color: String) {
        self.id = UUID()
        self.name = name
        self.icon = icon
        self.color = color
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}
```

---

### Entity 4: MonthlyBudget

**Purpose**: Global monthly spending limit

```swift
@Model
final class MonthlyBudget {
    // Identifiers
    @Attribute(.unique) var id: UUID
    
    // Fields
    var year: Int                   // 2025
    var month: Int                  // 1-12
    var limit: Double               // ‚Çπ50,000
    
    // Metadata
    var createdAt: Date
    var updatedAt: Date
    
    init(year: Int, month: Int, limit: Double) {
        self.id = UUID()
        self.year = year
        self.month = month
        self.limit = limit
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}
```

---

## üß© Part 2: Relationships

### Expense ‚Üî RecurringExpense

- An `Expense` can be linked to a `RecurringExpense` via `recurringExpenseId`
- One `RecurringExpense` can generate multiple `Expense` instances
- If a `RecurringExpense` is deleted, `Expense` records remain intact

### Expense ‚Üî CustomCategory

- An `Expense.category` can reference a `CustomCategory.id` or name
- One `CustomCategory` can have multiple `Expense` records
- If `CustomCategory` is deleted, existing expenses show "Archived Category"

### MonthlyBudget ‚Üî Expense

- No direct relationship (calculated on-demand)
- Query: Get all `Expense` where date is in (year, month)

---

## üß© Part 3: Enums & Constants

### Frequency Enum

```swift
enum RecurrenceFrequency: String, CaseIterable {
    case daily = "Daily"
    case weekly = "Weekly"
    case monthly = "Monthly"
}
```

### PredefinedCategory Enum

```swift
enum PredefinedCategory: String, CaseIterable {
    case foodDining = "Food & Dining"
    case transport = "Transport"
    case housing = "Housing"
    case healthMedical = "Health & Medical"
    case shopping = "Shopping"
    case utilities = "Utilities"
    case entertainment = "Entertainment"
    case travel = "Travel"
    case workProfessional = "Work & Professional"
    case education = "Education"
    case debtPayments = "Debt & Payments"
    case booksMedia = "Books & Media"
    case familyKids = "Family & Kids"
    case gifts = "Gifts"
    case other = "Other"
    
    var icon: String { ... }
    var color: String { ... }
}
```

---

## üß© Part 4: Queries & Filters

### Common Queries

**1. All Expenses This Month**
```swift
let calendar = Calendar.current
let now = Date()
let startOfMonth = calendar.date(from: calendar.dateComponents([.year, .month], from: now))!
let endOfMonth = calendar.date(byAdding: DateComponents(month: 1, day: -1), to: startOfMonth)!

let expenses = expenses
    .where { $0.date >= startOfMonth && $0.date <= endOfMonth && !$0.isDeleted }
    .sorted { $0.date > $1.date }
```

**2. Total Spent This Month**
```swift
let total = expenses
    .filter { /* same date range */ }
    .reduce(0) { $0 + $1.amount }
```

**3. Expenses by Category**
```swift
let byCategory = Dictionary(grouping: expenses) { $0.category }
    .mapValues { $0.reduce(0) { $0 + $1.amount } }
```

**4. Active Recurring Expenses**
```swift
let active = recurringExpenses
    .filter { $0.isActive && $0.startDate <= Date() }
```

**5. Expenses for Pie Chart**
```swift
let forPie = expenses
    .filter { /* this month, not deleted */ }
    .grouped(by: category)
    .sorted { $0.value.sum > $1.value.sum }
```

---

## üß© Part 5: Data Integrity

### Constraints

| Entity | Field | Constraint |
|--------|-------|-----------|
| Expense | amount | > 0 |
| Expense | date | ‚â§ today |
| Expense | time | Optional |
| RecurringExpense | startDate | ‚â§ today |
| RecurringExpense | endDate | ‚â• startDate (if set) |
| CustomCategory | name | Unique, max 30 chars |
| MonthlyBudget | limit | > 0 |
| MonthlyBudget | (year, month) | Unique |

### Soft Deletes

- `Expense.isDeleted = true` (not physical delete)
- `CustomCategory.isHidden = true` (not physical delete)
- Allows data recovery & historical integrity

---

## üß© Part 6: Migration & Versioning

### Swift Data Versioning

If schema changes:
1. Add `@ModelVersioned` macros (if available)
2. Create migration strategy
3. Backfill existing data

### Example: Adding a Field

```swift
// Version 1.1: Add "isRecurring" field to Expense
// Migration: Set isRecurring = true if recurringExpenseId is not nil
```

---

## üìè Storage & Performance

### Estimated Data Size

- 1 year of daily expenses: ~365 records ‚âà 200KB
- 50 custom categories: ~10KB
- 20 recurring templates: ~20KB
- **Total for 1 year**: ~250KB (very manageable)

### Indexing (Future)

For larger datasets (multiple years):
- Index on `Expense.date`
- Index on `Expense.category`
- Index on `Expense.recurringExpenseId`

---

## üéØ Acceptance Criteria

- ‚úÖ All entities defined in Swift Data
- ‚úÖ Relationships properly modeled
- ‚úÖ Soft deletes implemented
- ‚úÖ Unique constraints enforced
- ‚úÖ Common queries documented
- ‚úÖ Data validation rules clear
- ‚úÖ No data loss on category deletion
